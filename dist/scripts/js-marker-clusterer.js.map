{"version":3,"sources":["../bower_components/js-marker-clusterer/src/markerclusterer.js"],"names":["MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","resetViewport","redraw","length","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","size","i","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","maxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","Math","min","text","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","r","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","slice","window","setTimeout","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","d","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","l","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","panes","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join"],"mappings":"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","file":"js-marker-clusterer.js","sourcesContent":["// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n */\nClusterIcon.prototype.triggerClusterClick = function() {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function() {\n    that.triggerClusterClick();\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= parseInt(this.width_ / 2, 10);\n  pos.y -= parseInt(this.height_ / 2, 10);\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n"],"sourceRoot":"assets/scripts/"}